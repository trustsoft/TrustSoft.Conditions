<#
//  -------------------------------------------------------------------------------------------------------
//  Template: Generates C# code to give strongly-typed access to resx files
//  Author: Sukhanov Maxim (sukhanov.maxim@hotmail.com)
//  Links: 
//          MSDN about developing T4 files: http://msdn.microsoft.com/en-us/library/bb126445.aspx
//                                          http://msdn.microsoft.com/en-us/library/dd820620.aspx 
//  -------------------------------------------------------------------------------------------------------
#>
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	var namespaceName = "Trustsoft.Conditions";
	IServiceProvider serviceProvider = (IServiceProvider)this.Host;
	EnvDTE.DTE dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
	if (dte == null)
		throw new Exception("T4 can only execute through the Visual Studio host");

	var resKeys = GetResourceNames();
#>
// --------------------------------------------------------------------------------------------------------
// <auto-generated>
//     Runtime Version: <#= System.Environment.Version #>
//     This code was generated by a T4 Template at <#= DateTime.Now.ToString("dd-MM-yyyy, HH:mm:ss") #>.
//	   
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------

namespace <#= namespaceName #>
{
    #region " Using Directives "

    using System.Diagnostics;
    using System.Globalization;
    using System.Resources;

    #endregion

    internal static class <#= className #>
	{
		#region " String Resource Names "

		<# GenerateStringResourceConstants(resKeys); #>

		#endregion
		
		private static readonly ResourceManager resource;

        static <#= className #>()
        {
            resource = new ResourceManager(typeof(<#= className #>).Namespace + ".Resources.MessageStrings",
                                           typeof(<#= className #>).Assembly);
        }

		/// <summary>
        ///     Returns a string from the resource.
        /// </summary>
        /// <param name="resourceKey"> The resource key. </param>
        /// <returns> System.String. </returns>
        internal static string GetString(string resourceKey)
        {
            return resource.GetString(resourceKey);
        }

        /// <summary>
        ///     Returns a string from the resource and formats it with the given args in a culture-specific way.
        /// </summary>
        /// <param name="resourceKey"> The resource key. </param>
        /// <param name="args"> The arguments. </param>
        /// <returns> System.String. </returns>
        internal static string GetFormatedString(string resourceKey, params object[] args)
        {
            return GetStringInternal(resourceKey, args);
        }

        private static string GetStringInternal(string name, params object[] args)
        {
            string format = GetString(name);

            Debug.Assert(format != null, "resource.GetFormatedString() returned null for resourceKey=" + name);

            if (args == null)
            {
                return format;
            }

            return string.Format(CultureInfo.CurrentCulture, format, args);
        }
	}
}
<#+
string className = "StringRes";
string resourceFileName = "MessageStrings.resx";

private IEnumerable<string> GetResourceNames()
{
	//var templateFilePath = Path.GetFullPath(this.Host.TemplateFile);
	var templateFilePath = Path.GetDirectoryName(this.Host.TemplateFile);
	string resxFile = Path.Combine(templateFilePath, resourceFileName);
	using (System.Resources.ResXResourceReader resxReader = new ResXResourceReader(resxFile))
    {

		var resNames = new List<string>();
		foreach (DictionaryEntry entry in resxReader)
		{
			resNames.Add((string) entry.Key);      
        }
		
		return resNames;
    }
}

private void GenerateStringResourceConstant(string key)
{
	var line = string.Format("internal const string {0} = \"{0}\";", key);
	WriteLine(line);
}

private void GenerateStringResourceConstants(IEnumerable<string> keys)
{
    this.PushIndent("\t");
    this.PushIndent("\t");
	foreach (var key in keys)
    {
		 GenerateStringResourceConstant(key);
    }
	this.PopIndent();
	this.PopIndent();
}#>